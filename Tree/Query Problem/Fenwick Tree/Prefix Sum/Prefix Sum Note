<Prefix Sum Note>

<유형1>
- 누적합(Prefix Sum)을 이용하면 A[i]+...+A[j]를 쉽게 구할 수 있다.

- S[i]=A[1]+...+A[i]라 할때, S[i]를 미리 모두 채워놓을 수 있다.
- 이러한 선처리 작업을 하는데 걸리는 시간복잡도는 O(N)이다.

- A[i]+...+A[j]=S[j]-S[i-1]을 이용해서 구해주면 된다.
- 이러한 연산의 시간복잡도는 O(1)이다.
- Q개의 쿼리에 대한 시간복잡도는 O(Q)이다.


- 최종적인 누적합을 이용하여 구간합을 구하는 시간복잡도는 O(N+Q)이다.
- 이는 세그먼트 트리를 이용한 시간복잡도인 O(NlgN+QlgN)보다 매우 빠른 방법이다.

- 단, 배열의 어떠한 값을 변경할 때, 세그먼트 트리가 누적합보다 강점을 보인다.
- 누적합을 이용하면 시간복잡도가 O(N)이 걸리지만, 세그먼트트리는 O(lgN)이 걸리기 때문이다.
============================================================================================
<유형2>
- 누적합(Prefix Sum)을 이용하면 A[i]+...A[j]의 값이 k를 만족하는 (i,j)쌍의 개수를 구할 수 있다.

- cnt[]를 만들어 놓아서 s[i]==2일때, cnt[2]에 1을 추가하는 방법으로 s[x]=i인 cnt[i]=(가능한 x의 개수)거 되도록 놓는다.
- cnt[]는 map으로 구현해야 한다.

- 이때, s[j]-s[i-1]에 대해서 가능한 s[i-1]의 개수를 cnt[]를 통해서 O(1)에 얻을 수 있다.

- 최종적인 누적합을 이용하여 구간합의 개수쌍을 구하는 시간복잡도는 O(N+Q*N)이다.
============================================================================================
< 2차원 누적합 >

- 2차원 배열에서 x1~x2, y1~y2 구간에서의 합을 저장해 놓는 방법

- s[i][j]= (1,1)~(i,j)까지의 합.
- s[i][j]= s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]

- (a,b)~(c,d)의 합도 포함과 배제의 원리를 이용해서 구할 수 있다.
- s[c][d] - s[c][b-1] - s[a-1][d] + s[a-1][b-1]
============================================================================================