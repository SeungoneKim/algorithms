<Floyd-Warshall Note>

- 다른 모든 정점에서 다른 모든 정점까지의 모든 최단 경로를 구하는 알고리즘이다. (All pairs shortest path problem)
- 다이나믹 프로그래밍을 이용해서 구현하는 알고리즘이다.
- 플로이드 와샬 알고리즘은 다익스트라와 달리 음수인 가중치를 가진 간선이 존재해도 괜찮지만, 벨만포드와는 달리 음수 사이클이 존재하면 안된다.

- 시작점인 1개인 경우를 V번 하면 모든 쌍의 최단경로를 구할 수 있다.
- 따라서 다익스트라나 벨만포드 알고리즘을 V번 돌려도 결과는 크게 차이가 없지만, 플로이드-와샬 알고리즘은 코드가 간단하다는 큰 장점이 있다.

- 시간 복잡도는 총 O(V^3)이라고 볼 수 있다.
/*
// code

for(int k=1;k<=n;k++){
    for(int t=1;t<=n;t++){
        for(int j=1;j<=n;j++){
            if(d[t][j] > d[t][k] + d[k][j]){
                d[t][j] = d[t][k] + d[k][j];
            }
        }
    }
}

*/

- d[k][i][j]를 i->j로 갈때, 사이에 1~k가 사용되는 경우의 수라고 하자.
- k가 있을 때는 d[k-1][i][k] + d[k-1][k][j]이다.
- k가 없을 때는 d[k-1][i][j]이다.

- 따라서, d[k][i][j] = min(d[k-1][i][k]+d[k-1][k][j], d[k-1][i][j])이다.
- 이때, k를 모두 지워서 2차원 배열로 구현해도 문제는 없다.
- 결론적으로 d[t][j]= min(d[t][j],d[t][k]+d[k][j])임을 알 수 있다.


<플로이드-와샬 문제풀이>
1. 플로이드 와샬에서 백트래킹을 할 때는, 보편적으로 사용하는 before[]배열을 사용하면 안된다.
-> a->b->...->c일 때, next[a][c]=b로 저장하면 된다.
-> a==c일 때, next[a][c]=c로 저장하면 된다.

2. 플로이드 와샬 알고리즘을 이용해서 방향 간선으로 이루어진 사이클이 있는지 찾을 수 있다.
-> 사이클을 이루지 않고, 방향그래프라면 DAG구조이다.

3. 플로이드 와샬 알고리즘을 이용하면 DAG구조인지 아닌지 확실하지 않은 그래프에 대해서 정점간의 우선순위를 파악할 수 있다.