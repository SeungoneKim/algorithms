<Binary Search Note>
- 이분탐색은 정렬이 되어있는 리스트에서 어떤 값을 빠르게 찾는 알고리즘이다.
- O(lgN)의 시간복잡도가 걸린다.


- 이분탐색을 할 때, 어떤 수열 A에 대해서 K의 상한은 크거나 같은 수, 하한은 작거나 같은 수를 의미한다.
- 보통 구현 할때 상한은 큰 수 중에서 첫번째 수, 하한은 크거나 같은 수 중에서 첫번째 수로 생각하면 된다.


- 이분탐색으로 풀 수 있는 문제 유형은 크게 2가지 있다.
1. 정답을 구하는 문제
2. 가능한지 살펴보는 문제

- 정답을 구하는 문제는 최적해를 구하는 문제인 반면, 가능한지 살펴보는 문제는 가능한지 살펴보는 문제는 Yes/No 문제이다.

- 1번 문제를 풀수 있으면 2번 문제를 풇 수 있다.
-> 주어진 x와 정답 사이의 대소 관계를 살펴보면 된다.

- 2번 문제를 풀수 있어도 1번 문제를 풀 수 있다.
-> 특정한 구간에 대해서 가능한지 살펴볼 때, 계속 No이다가 Yes가 되는 지점, 혹은 계속 Yes이다가 No가 되는 지점이 최적해이다.
-> 최솟값을 찾을 때는, No->Yes로 변하는 지점을, 최댓값을 찾을 때는 Yes->No로 변하는 지점을 찾으면 된다.

- 이분탐색으로 정답을 찾는 것은 매우 중요한 기법이다.
- 직접 해를 구하기는 힘들지만 Yes/No 여부는 구하기 쉬운 경우에 특정한 구간에 대해 이분탐색으로 2번문제를 쭉 풀면서 1번 문제를 풀 수 있다.

- 이분탐색을 할 때는 다음 4가지를 결정해야 한다.
1. 가능한 정답의 최솟값(left)
2. 가능한 정답의 최댓값(right)
3. 정답을 하나 결정했을 때, 이것이 문제의 조건에 맞는지 검사하는 함수
4. 조건에 맞을 경우, 정답을 더 크게 해야하는지 작게해야하는지 판단하는 조건문

- 문제가 막힐땐 left,right,mid로 설정해야하는 것과 이것을 calculation에 넣었을 때 나오는 값이 뭔지 고민해보면 된다!

/*
// code

    int left=1;
    int right=n;
    int ans=0;

    while(left<=right){
        int mid = (left+right)/2;
        long long sol = calculation(mid); // 문제의 조건에 맞는지 검사하는 함수

        // 정답을 더 크게 해야하는지 작게해야하는지 판단하는 조건문
        if(sol<k){
            left = mid+1;
        }
        else{
            if(mid>ans) ans=mid;
            right= mid-1;
        }
    }

*/

- left,right,mid,answ 혹은 calcualtion을 한 값이 커보이면 모두 long long으로 처리해야한다.

- 최댓값이나 최솟값의 최댓값이나 최솟값을 찾을 때 이분탐색을 이용하는 경우가 많다.

<Binary Search at Rational Number>

- 실수에서 이분탐색을 하면 다음과 같은 표현들을 바꿔야할 필요가 있다.
1. left=mid+1; -> left=mid;
2. right=mid-1 -> right=mid;
3. while(left<=right) -> while(abs(right-left)>1e-6)




<Ternary Search Note>

- 최소값 또는 최대값이 하나인 함수(Unimodal function)에서 최소/최대를 찾는 방법
- 이분탐색과 달리 삼등분을 한다.

- 대부분 실수에서 사용하게 된다.

/*
// code finding maximum

while(true){
    if(abs(right-left)<1e-9) return (left+right)/2;
    double m1=left + (right-left)/3;
    double m2=right - (right-left)/3;
    if(func(m1)<func(m2)){
        left=m1;
    }
    else{
        right=m2;
    }
}