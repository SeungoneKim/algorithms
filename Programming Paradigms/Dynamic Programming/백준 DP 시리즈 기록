===============================================================================
DP1: 
1. number[k] Type : BFS Simulation과는 다른 DP Simulation.
- 횟수의 최대,최소값
- 방법의 수 : 점화식 세우기
- 외부값의 최대,최소값
+) number k 는 rownum,index,order,number 중 하나인데 이를 크게 구분할 필요는 없다.
+) 숫자 k를 해석할 때, k번째 숫자를 포함했을 때와 k번째 숫자까지 고려했을 때를 구분할 필요가 있다.

2. status[k] Type
- Last Digit
- Simulation Status

+) 2차원 배열을 두어서 다이나믹에서 number k 외에 다른 특성을 기록할 수 있는 방법

3. index[i]~index[j] Type
- index i & index j (시작 s, 끝 e)

+) 가정하는 메소드 : k가 rownum,index일때 포함한다고 가정하고 푸는 방법

어려운 문제:
1) 방법의 수를 점화식 어렵게 내는 경우
2) 상태 k에 따라서 여러가지 관계식이 얽혀있는 경우
3) k번째 원소가 포함되어 있다고 가정해야하는 경우
4) index i에 대해서 1~i-1을 t로 순회하는 경우

===============================================================================
DP2:
1. number[k] Type
+) 중복처리 : 종류를 number k보다 먼저 처리해주기

- DP Simulation 유형 : 하나의 경우가 여러가지 경우를 파생시킬때, dp table(배열)을 두어 이를 기록하는 방법
- 이는 BFS의 graph modeling과 상당히 유사하다고 볼 수 있다.
+) Bottom Up : 바로 직전 k-1에서 유효한 값을 찾을 때, 1~(가능한 value)에 대한 검색이 선행되어야하는 경우가 있다.
+) Top Down : k의 길이가 정해져 있지 않을 때, 모든 경우에 대해서 재귀함수의 형식으로 탐색한다.

3. index[i]~index[j] Type
- index i & length k (기준 i, 길이 k) : dp 배열 대각선 기준으로 채우기

4. tile[i][j] Type
- Not "BFS Flood Fill"
================================================================================
DP3:
1. number[k] Type
+) binomial 미리 계산하여 수학적 관계식에서 곱해주기
+) 대각화 method
+) 교란순열

+) Simulation : Top-Down...

2. Status[k] Type
사용한 정보 바탕으로 3차원,4차원 DP도 얼마든지 만들 수 있음.

3. index[i]~index[j] Type
좌표 정보를 index 1~n으로 바꾸어서 처리할 수 있음.

4. Tile[i][j] Type
+) Graph Type Problem : Node 각각을 하나의 칸으로
-> Similar to Bellman-Ford

5. Time[k] Type
- 같은 칸도 다른 시간에서 다른 정보를 가지고, 다른 상황일 수 있다.
================================================================================
DP4:

2. Status[k] Type
이전 state에 대한 정보를 [k]에 비트마스크 형식으로 기록해두고, 이에 대한 정보를 바탕으로 dp배열을 채워나갈 수 있다.
+) 2중 for문으로 이전 state와 현재 state 관계식 : O(2^NM)
+) row major order을 이용한 풀이 : O(N*2^M)

+) 행렬을 이용한 상태다이나믹:
계산해야하는 범위 N이 너무 클 때 lgN으로 계산을 빠르게할 수 있다.
- 행렬 관계식으로 바꾸어 작성한 후 곱셈을 진행한다.
================================================================================
DP5:

2. Status[k] Type
트리 자료구조에서 어떤 노드가 선택되었는지 아닌지에 대한 정보를 [k]에 기록해두고, 자식노드의 dp배열에서의 정보를 바탕으로 dp배열을 채워나갈 수 있다.
+) 트리 다이나믹을 할때는 위에서 부터 채워나가기 보다는, 아래까지 쭉 호출한 후에 차례대로 올라가면서 자식노드에 대한 정보를 바탕으로 부모노드를 채워나가는 것이 더 유리하다.

+) N범위가 너무 클 때, 항상 행렬을 써서 시간복잡도를 줄일 수 있는지 생각해본다.

1. number[k] Type
+) kth 유형
dp[]배열을 우선적으로 채워넣은 후, k번째를 printer라는 함수를 통해 찾는다.
printer 안에서는 k와 dp를 비교해가면서 출력을 하고, k를 갱신하는 작업을 한다.

+) memoization에 사용할 자료구조가 N의 범위가 너무 클 때는 map을 사용하거나, 특정한 범위 K까지만 memoization을 한다.

+) dp[]배열이 너무 커서 메모리 초과가 날 때, dp관계식이 i와 i-1 사이의 관계식이라면, dp[2][]로 두고 매번 다음 i를 초기화하면서 진행할 수 있다.

+) bool dp[]배열이 메모리가 너무 크다면 bitset 자료구조를 이용해서 메모리를 1/8배로 줄일 수 있다.