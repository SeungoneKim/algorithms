<Status[k]Type Note>

- 상태[k]를 적절하게 잘 잡는 것은, 다이나믹 프로그래밍 문제를 잘 해결할 수 있는 핵심적인 열쇠라고 할 수 있다.

- 대표적으로 상태 k를 지정할 수 있는 예시는 다음과 같다.
1. n번째 자릿수에서 사용한 숫자 or n-1번째 자릿수에서 사용한 숫자
2. t개까지 사용가능한데, 직전에 k개까지 사용한 상황
3. 직전에 사용가능한 상황중 어떠한 상황을 지정
(ex_0:직전에 안사용, 1:윗변을 사용, 2:아랫변을 사용)


========================================================================================
<비트마스크>
- 채워진 상태를 비트마스크를 이용하여 숫자로 나타낼 수 있으면, 그 상태를 dp배열의 상태정보로 두어서 채워나간다.

- k=N-1꺄지 각각의 상황은 dp배열의 상태 정보로 저장해 둘 수 있다는 것이 엄청 큰 의의이다.



- row의 state와 row-1의 state를 비교하여 dp배열을 채우는 유형의 문제가 존재한다. (ex_ 타일채우기)
- 이는 O(2^(2*rowsize))의 시간복잡도를 동반하기 때문에 보다 효율적인 방법이 필요할 수 있다.
- row-major order를 사용한다. 
- row-major order = rowsize*r+c (0<=c<colsize)
- 즉, 각각의 칸에 번호를 매기고, state는 rowsize개 씩 끊어서 보겠다는 것이 핵심적인 아이디어이다.

- O(2^rowsize)*(NM)으로 개선할 수 있다.
- 이는 시간단축을 크게 할 수 있는 방법이다.

- 비트마스크를 이용하여 수를 표현할 수 있는 대상은 채워진 칸, 사용한 것에 대한 정보이다.
1) 블록의 칸을 썼는가
2) 주어진 N개의 수를 썼는가
등등

BJ1555) Set을 사용해서 state dp를 해결하는 방법

- 비트마스크로 다음 N개의 상태를 저장해놓을지, 전에 N개의 상태를 저장해놓을지는 직접 정할 수 있다.
ex) BJ1657은 다음 N개, BJ14275는 전 N개
- 상태의 종류가 3가지이면 3진법으로 표현할 수 있다.
ex) BJ14275

========================================================================================
<행렬>

- 다이나믹에서 유명한 문제는 피보나치이다.
- 이를 행렬로 표현할 수 있다.
D[i]            1   1           D[i-1]
            =              *    
D[i-1]          1   0           D[i-2]

따라서,
D[i]            1   1   i-1승           D[1]
            =                   *
D[i-1]          1   0                   D[0]

- 총 O(N^3 * lgi)의 시간복잡도가 소요된다.