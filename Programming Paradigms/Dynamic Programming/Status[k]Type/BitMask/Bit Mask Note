<Bit Mask Note>

- bit연산을 사용해서 부분 집합을 표현할 수 있다.

<1>
- &and, |or, ~not, ^xor

- bit연산의 시간복잡도는 O(1)이다.

- not연산을 할 때는 자료형에 유의해야한다.

<2>
- shift left<<, shift right >>

- 2^N = 1<<N
- (A+B)/2 = (A+B)>>1

- shift연산을 할 때는 연산자 우선순위에 유의해야한다.


- Bit Mask은 정수로 집합을 나타낼 수 있다는 아이디어에서 나온다.
ex) {1,3,4,5,9} = 570 = 2^1+2^3+2^4+2^5+2^9

- 시간, 공간을 크게 절약할 수 있다는 장점이 있다.
- 비트마스크를 사용할 때에는 무조건 0~n-1로 처리를 해야만 한다.

<bit연산1 : 검사연산 using &>
{1,3,4,5,9}=570

1) 0 이 있는지 검사
570 & (1<<0)=0

2) 1 이 있는지 검사
570 & (1<<1)=2

3) 2 가 있는지 검사
570 & (1<<2)=0

4) 3 이 있는지 검사
570 & (1<<3)=8

<bit연산2 : 추가연산 using |>
{1,3,4,5,9}=570

1) 1 추가하기
570 | (1<<1)= 570

2) 2 추가하기
570 | (1<<2)= 574

<bit연산3 : 제거연산 using ~,&>
{1,3,4,5,9}=570

1) 1 제거하기
570 & ~(1<<1)= 568

2) 2 제거하기
570 & ~(1<<2) = 570

<bit연산4 : 토글하기 using ^>
1) 1 토글하기
570 ^ (1<<1) = 568

<bit연산5 : 전체집합, 공집합>
전체집합 : (1<<N)-1
공집합 : 0

- N개 중에서 일부를 선택하는 문제에서 비트마스크를 사용할 수 있다.

/*
//code 

int answ=0;
for(int k=1;k<= (1<<vecsize)-1;k++){
    int sum=0;
    for(int t=0;t<vecsize;t++){
        if(k&(1<<t)){
            sum+=numbers[t];
        }
    }
    if(sum==goal) answ++;
}

*/

- 비트 마스크는 저장해야하는 정보가 너무 방대할 때, 정보를 비트마스크로 표현한 수로 대신 저장하는 용도로 쓸 수도 있다.