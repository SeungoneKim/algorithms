<Greedy Note>

- 무엇인가를 결정해야 할 때, 그 순간에 가장 좋다고 생각하는 것을 선택하면서 답을 찾는 알고리즘이다.
- 그 때 그 때는 최적이지만, 최종적으로 답이 최적이 아닐 수도 있다.

- 그 순간에 최적의 선택이 전체적으로도 최적의 선택이라는 기준이 필요하다.
- 어떤 문제가 그리디 알고리즘임을 증명할 때, 수학적인 증명이 필요하다.

<예시>
1. 주어진 입력을 정렬하거나, 미리 선택할것을 결정하여, 앞에서부터 선택하면 그리디 알고리즘이 성립하는 문제도 존재한다. (Choice)
+ 배수 문제는 배수의 특징을 고려하여 수를 정렬하여 확인한다. (Multiple)
+ 거스름돈 문제는 줄 수 있는 돈이 서로 '배수관계'일때만 그리디 알고리즘이 성립한다. (Money)
+ 회의 문제는 빨리 끝나는 회의를 배정해주면 그리디 알고리즘이 성립한다. (Meeting Room)

2. 주어진 입력을 어떠한 상태로 변화할 수 있는지 그리디 알고리즘으로 확인하는 문제가 존재한다. (Changing Status)
-> 유일하게 변화를 줄 수 있는 상태 또는 조건에 대한 기준점을 잡는다.

3. 주어진 입력내에서 특정한 조건을 만족하면서 최적의 이익을 얻을 수 있는지 그리디 알고리즘으로 확인하는 문제가 존재한다.(Max Profit)
-> BST 또는 Heap을 이용해야한다.

4. LIS 문제는,
+ LIS를 구하는 문제는, 크거나 같은 수 중에서 가장 작은 수(lower bound)에 해당 하는 수를 계속 갱신하는 그리디 알고리즘으로 풀 수 있다.
-> 이 방법으로는 수의 길이만 구할 수 있다. LIS를 구하기 위해서는 앞 수의 index를 기록하는 배열을 만들면 된다.

+ LIS와 LDS가 주어진 상태에서 수열을 구하는 문제는, 1,2,...,N이라는 구간을 M개의 그룹으로 나누고, K개를 각 그룹의 최대 원소개수라 한다.
  이때, 각 그룹단위로 역순으로 뒤집으면 된다. 
  이때, Erdos-Szekeres Theorem에 의해서 N<=MK가 성립하게 된다. (N=MK+1이상이면 그룹의 개수가 N+1이거나 각 그룹중에서 원소가 K+1인 그룹이 존재하게 된다.)

5. '수학적인 관계식'또는 '패턴'을 통해서 브루트포스같아 보이는 문제를 그리디를 통해 특정한 상황만 고려함으로써, 보다 적은 경우의 수들만 비교할 수 있다.(Not Brute Force)

- 그리디에 대한 증명은 그리디 방법을 정답이라 가정하고, 변화를 주었을 때 실제 답보다 값이 더 커지는 것을 보이면서 증명한다.